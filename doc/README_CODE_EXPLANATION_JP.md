# Cub3D ソースコード完全解説

このドキュメントでは、Cub3Dプロジェクトの全ソースコードについて、ファイルごとの概要と、コードの各行（または論理ブロック）の意図を詳細に解説します。

---

## 1. エントリーポイント & コア (src/core, main.c)

### `src/main.c`
**概要**: プログラムの開始点。引数処理、初期化、メインループの開始を行います。
**コード解説**:
- **L1-11**: 42ヘッダー。
- **L13**: `#include "cub3d.h"`。プロジェクト全体の定義を含むメインヘッダーを読み込みます。
- **L15**: `main` 関数定義。
- **L16**: `t_game game;`。ゲームの状態を保持する巨大な構造体をスタック領域に確保します。
- **L18-19**: `argc != 2` チェック。引数が正しくない場合、エラーメッセージを出して終了します。
- **L20-21**: `check_filename` (parsing/check_file.c) を呼び出し、拡張子が `.cub` か確認します。不正なら終了。
- **L22**: `init_game(&game)` (core/game_init.c) を呼び出し、構造体のメンバを初期化（ゼロクリア等）します。
- **L23**: `parse(argv[1], &game)` (parsing/parse_main.c) を呼び出し、マップファイルを読み込んで構造体にデータを格納します。
- **L24-25**: `init_window(&game)` (core/window.c) を呼び出し、MLX（グラフィックライブラリ）の初期化とウィンドウ作成を行います。失敗時は終了。
- **L26-27**: `init_textures(&game)` (parsing/textures_init.c) を呼び出し、テクスチャ画像の読み込みを行います。
- **L28**: `init_sprites` (render/sprite.c) を呼び出し、スプライト（アイテム等）の情報を初期化します。
- **L29**: `mlx_loop(game.mlx)`。イベントループに入り、ゲームを開始します。ここからプログラムは終了指示があるまでループし続けます。
- **L30**: 関数の終了（通常ここには到達しません）。

### `src/core/game_init.c`
**概要**: ゲーム構造体 `t_game` の初期化を行う関数群。
**コード解説**:
- **L4 `init_parse`**: パース（解析）に関連する変数に初期値（主に `-1` や `NULL`）を設定します。
    - **L5-8**: テクスチャパスを `NULL` に。
    - **L9-14**: 床・天井の色を `-1` に（未設定状態を区別するため）。
    - **L15-17**: マップ情報（グリッド、幅、高さ）を初期化。
    - **L18-22**: プレイヤー位置・方向を初期化。
- **L25 `init_game`**: `t_game` 全体をリセットします。
    - **L28**: `ft_bzero` で構造体全体をバイト単位でゼロクリア。これにより、明示的に設定しないポインタも `NULL` になります。
    - **L33-36**: 壁テクスチャ配列 `wall_tex` の `img` ポインタを明示的に `NULL` 化（安全のため）。
    - **L37-39**: ドアやスプライト用テクスチャも同様に初期化。
    - **L41**: `init_parse` を呼び出し、パース用変数をセット。

### `src/core/window.c`
**概要**: ウィンドウ作成、MLX初期化、イベントフックの設定。
**コード解説**:
- **L3 `close_game`**: ゲーム終了時のクリーンアップ処理。
    - **L5**: `free_all` (core/game_cleanup.c) を呼び、全メモリを解放。
    - **L6**: `exit(0)` で正常終了。
- **L10 `init_window`**: MLXのセットアップ。
    - **L14**: `mlx_init()` で接続を確立。
    - **L18-19**: 画面サイズを 1024x768 に設定。
    - **L21**: `mlx_new_window` でウィンドウを作成。
    - **L25**: `mlx_new_image` で描画用の裏画面（オフスクリーンバッファ）を作成。直接ウィンドウに描くと遅いため、一度画像に描画してから表示します。
    - **L26-27**: `mlx_get_data_addr` で画像のピクセルデータへのポインタを取得（直接書き込むため）。
    - **L31**: `z_buffer`（奥行きバッファ）用のメモリを確保。スプライト描画の前後判定に使用。
    - **L35**: `mlx_hook(..., 2, ...)`。キーが押された時のイベント (KeyPress) に `key_press` 関数を登録。
    - **L36**: `mlx_hook(..., 6, ...)`。マウス移動イベントに `mouse_handler` を登録。
    - **L37**: `mlx_hook(..., 17, ...)`。ウィンドウの×ボタンが押された時のイベント (DestroyNotify) に `close_game` を登録。
    - **L38**: `mlx_loop_hook`。何もイベントがない時に毎フレーム呼び出される関数として `render_frame` (render/render.c) を登録（これが描画ループになります）。

### `src/core/game_cleanup.c`
**概要**: メモリ解放処理。エラー終了時や正常終了時に呼び出され、リークを防ぎます。
**コード解説**:
- **L15 `free_split`**: `ft_split` などで確保された文字列配列（`char **`）を解放するユーティリティ。
    - **L21-22**: 内部の各文字列を解放。
    - **L23**: 配列自体のポインタを解放。
- **L26 `free_all`**: ゲーム構造体内の全リソースを解放。
    - **L27-34**: テクスチャのパス文字列（NO, SO, WE, EA）を解放。
    - **L35-36**: マップデータ（文字列配列）を解放。
    - **L37-38**: Zバッファ配列を解放。
    - **L39-40**: スプライト配列を解放。
    - **L41-62**: MLX関連のリソース解放。
        - **L45**: `mlx_destroy_image` で読み込んだテクスチャ画像を破棄。
        - **L56**: メイン描画用画像を破棄。
        - **L58**: ウィンドウを破棄。
        - **L60-61**: ディスプレイ接続を破棄し、ポインタを解放（Linux/WSL環境でのリーク防止）。

### `src/core/error.c`
**概要**: エラーハンドリング。
**コード解説**:
- **L15 `perror_and_exit`**: エラーメッセージを表示してプログラムを終了させる。
    - **L16-17**: 標準エラー出力に "Error\n" と詳細メッセージを出力（課題要件）。
    - **L18-19**: `game` 構造体が渡されていれば `free_all` でクリーンアップ。
    - **L20**: `exit(1)` で異常終了。

---

## 2. 解析モジュール (src/parsing)

### `src/parsing/parse_main.c`
**概要**: `.cub` ファイル解析のメインロジック。
**コード解説**:
- **L3 `process_elem_line`**: マップ要素（テクスチャパスや色）の行を処理。
    - **L4-14**: 空行やコメント行(`#`)をスキップ。
    - **L17-20**: `parse_texture` または `parse_color` を呼び出し、成功すればカウントを増やす。
- **L27 `parse_elem`**: 必須要素（NO, SO, WE, EA, F, C の6つ）が揃うまで読み続ける。
    - **L32**: 無限ループで `get_next_line`。
    - **L36-40**: 要素解析に失敗した場合（未知の識別子など）、まだ6つ揃ってなければエラー。
    - **L41**: 要素でない行（マップデータと思われる行）に到達したら、その行を返す。
- **L49 `parse`**: 解析処理の全体フロー。
    - **L53**: ファイルを開く。
    - **L58**: `parse_elem` で要素を読み込み、最初のマップ行(`first_line`)を取得。
    - **L59**: `parse_map` (parse_map.c) に `first_line` を渡してマップ部分を解析。
    - **L61-65**: マップの検証（文字、閉鎖性、プレイヤー存在）を行い、不正ならエラー終了。

### `src/parsing/parse_map.c`
**概要**: マップデータ部分（0, 1, N, S...）の読み込みとメモリ確保。
**コード解説**:
- **L5 `process_map_line`**: 読み込んだ1行をマップ配列に追加。
    - **L9-13**: 行が空行の場合（マップ後の空行など）は、`map_ended` フラグを立てる（マップ途中の空行は禁止のため）。
    - **L15**: 既にマップ終了フラグが立っているのに行が来た場合（分離マップ）、エラー(0)を返す。
    - **L23**: `change_line_to_map` (utils) で現在のマップ配列を拡張して行を追加。
- **L32 `normalize_map`**: マップの各行の長さを揃える（矩形にする）。
    - **L39-44**: 最長幅に合わせてメモリ確保し、足りない部分をスペースで埋める。
- **L55 `read_lines`**: GNLでファイルの最後まで読み込み、`process_map_line` を繰り返す。
    - **L61**: `parse_elem` から渡された `first_line` から処理開始。
- **L73 `parse_map`**: マップ解析のエントリー。`read_lines` と `normalize_map` を統括。

### `src/parsing/parse_textures.c`
**概要**: テクスチャパス（NO, SO, WE, EA）の解析。
**コード解説**:
- **L15 `set_texture`**: パス文字列を検証して保存。
    - **L26**: 拡張子が `.xpm` であるかチェック。
- **L32 `parse_texture`**: 行をスペースで分割し、識別子（NO等）に対応する変数を設定。

### `src/parsing/parse_colors.c`
**概要**: 床・天井の色情報（F, C）の解析。
**コード解説**:
- **L15 `check_digits`**: 文字列が数値のみで構成されているか確認。
- **L31 `set_rgb`**: 文字列配列からRGB値を取得し、0-255の範囲かチェック。
- **L46 `validate_commas`**: カンマが正確に2つあるか確認（`1,,2` などを弾く）。
- **L62 `parse_rgb_line`**: "220,100,0" のような文字列を解析。
- **L91 `parse_color`**: "F 220,100,0" のような行を解析し、`parse_rgb_line` に渡す。

### `src/parsing/valid_map.c`
**概要**: マップの整合性チェック。
**コード解説**:
- **L13 `check_map_chars`**: マップ内に許可された文字（012NSEWスペース）以外が含まれていないか全走査。
- **L49 `check_map_closed`**: マップが壁で閉じられているか確認（Flood fill的なチェック）。
    - **L36 `check_surroundings`**: 床（0）やプレイヤー（NEWS）の周囲8方向にスペース（外）がないか確認。もしあれば、壁で囲まれていないためエラー。

### `src/parsing/parse_player.c`
**概要**: プレイヤーの初期位置と向きの設定。
**コード解説**:
- **L3 `set_direction`**: 文字（N/S/W/E）に応じて、方向ベクトル(`dir_x`, `dir_y`)とカメラ平面ベクトル(`plane_x`, `plane_y`)を設定。
    - 例: 'N' なら `dir_y = -1` (上), `plane_x = 0.66` (視野角確保)。
- **L35 `find_player`**: マップ全体を走査し、プレイヤーが**ただ1人**存在することを確認。見つけたらその座標をセットし、マップ上の文字を '0'（床）に置き換える。

### `src/parsing/check_file.c`
**概要**: ファイル拡張子チェック。
- `.cub` で終わっているかを文字比較で判定。

### `src/parsing/textures_init.c`
**概要**: 実際の画像ファイルのロード。
**コード解説**:
- **L3 `load_texture`**: パスから `mlx_xpm_file_to_image` を呼び出して画像を読み込み、`game->wall_tex` 等に格納。
- **L23 `init_textures`**: 全てのテクスチャ（東西南北、ドア、スプライト）に対して `load_texture` を実行。

---

## 3. エンジン & レンダリング (src/engine, src/render)

### `src/engine/raycast.c`
**概要**: レイキャスティングの核となる計算処理。
**コード解説**:
- **L4 `init_ray`**: 各垂直ラインごとのレイ（光線）を初期化。
    - **L7-9**: カメラ平面を使ってレイの方向ベクトルを計算。
    - **L12-13**: `delta_dist`（次のグリッド線までの距離）を計算。
- **L61 `raycast`**: 画面の左端から右端まで (`x = 0` to `width`) ループ。
    - **L69**: レイ初期化。
    - **L70**: `perform_dda` (utils) で壁に当たるまでレイを飛ばす。
    - **L71**: `calc_wall_and_tex` で壁の距離と描画開始・終了位置を計算。
    - **L73**: 天井と床を描画。
    - **L74**: 壁をテクスチャマッピングして描画。

### `src/engine/raycast_utils.c`
**概要**: レイキャスティングの補助計算。
**コード解説**:
- **L3 `perform_dda` (DDAアルゴリズム)**:
    - **L4**: `hit`フラグが立つまでループ。
    - **L5-13**: レイが次のXグリッドまたはYグリッドのどちらに近いかを判定し、短い方へ1ステップ進める。`side` (0:南北, 1:東西) を記録。
    - **L19**: マップ上の壁 ('1') かドア ('D') に当たったら `hit = 1`。
- **L25 `select_texture`**: 壁の向き (`side` と `ray_dir`) に応じて、使用するテクスチャ（北・南・西・東）を選択。
- **L41 `init_ray_step_x/y`**: レイの初期位置から最初のグリッド線までの距離(`side_dist`)と、進む方向(`step`)を計算。

### `src/render/render_frame.c` (render.c)
**概要**: 1フレームの描画フロー。
**コード解説**:
- **L61 `render_frame`**: メインループコールバック。
    - **L62**: `raycast` で3Dビュー作成。
    - **L63**: `draw_sprites` でアイテム描画。
    - **L64**: `draw_minimap` でミニマップ描画。
    - **L65**: `mlx_put_image_to_window` で完成した画像をウィンドウに転送（表示）。

### `src/render/minimap.c`
**概要**: 画面端に表示される2Dミニマップ。
**コード解説**:
- **L30 `draw_minimap`**: マップ配列をループし、壁なら白、床なら黒の矩形を描画。
- **L63**: プレイヤー位置に赤色の点を描画。
- **注**: マクロ `MM_SCALE` 等は `render.h` に定義移動済み。

### `src/render/sprite.c` & `sprite_utils.c`
**概要**: スプライト（アイテム '2'）の描画。
**コード解説**:
- **L54 `draw_sprites`**: ビルボード処理（常にプレイヤーの方を向く）。
    - プレイヤーからの距離を計算し、遠い順にソート（`sort_sprites`）。
    - 遠いものから順に描画（上書き）することで前後関係を正しく表示。
- **L28 `setup_sprite_vars`**: 3D空間上の位置をカメラ平面を使って2D画面上の位置に変換。

---

## 4. 入力処理 (src/input)

### `src/input/action.c`
**概要**: キー入力に対するアクション。
**コード解説**:
- **L6 `interact_door`**: 'E' キーでドアを開閉。目の前のグリッドが 'D' (閉) なら 'O' (開)、逆なら戻す。
- **L24 `key_press`**: キーコードに応じた関数を呼び出し。
    - **ESC**: 終了。
    - **W/A/S/D**: 移動。
    - **←/→**: 回転。
    - **E**: ドア操作。

### `src/input/movement.c`
**概要**: プレイヤーの前後左右移動。
**コード解説**:
- **L4 `move_forward`**: 現在の方向ベクトルに進む。
    - **L12-19**: 壁との衝突判定のための少し先の座標(`check_x`, `check_y`)を計算（`COLLISION_BUFFER` 使用）。
    - **L20**: 移動先が壁('1')や閉じたドア('D')でなければ、座標を更新。
- *他の移動関数も同様のロジック。*

### `src/input/rotate.c`
**概要**: プレイヤーの視点回転。
**コード解説**:
- **L4 `rotate_player`**: 回転行列を使って方向ベクトル(`dir`)とカメラ平面ベクトル(`plane`)を回転させる。
    - 公式: `x' = x * cos(θ) - y * sin(θ)`, `y' = x * sin(θ) + y * cos(θ)`。

### `src/utils/utils.c`
- 基本的なヘルパー関数（絶対値計算など）。

---
