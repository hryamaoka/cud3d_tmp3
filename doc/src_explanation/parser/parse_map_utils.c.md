# `src/parser/parse_map_utils.c` 詳細解説

## 概要
マップパース処理で使用されるヘルパー関数群です。動的な配列サイズの拡張（行追加）や、行末の改行コード削除など、`parse_map.c` の処理を補助します。

## 依存関係
*   `parse.h`: パース用ヘッダ。
*   `libft.h`: `ft_strchr` 等。

## 関数詳細

### 1. `change_line_to_map`
#### プロトタイプ
`char **change_line_to_map(char **map, char *line, int height)`

#### 戻り値
*   `char **`: 新しい行が追加されたマップ配列へのポインタ。
*   `NULL`: メモリ割り当て失敗時。

#### 解説
現在のマップ配列 `map` よりもサイズが1つ大きい新しい配列 `new_map` を確保し、古いデータをコピーした後、末尾に新しい行 `line` を追加します。古い配列 `map` は解放されます。実質的に `realloc` のような動作を行います。

#### コード行別解説 (`change_line_to_map`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 21 | `new_map = malloc(sizeof(char *) * (height + 2));` | **メモリ再確保**<br>現在の高さ + 新しい行数(1) + 終端NULL(1) 分のポインタ配列を確保します。 |
| 25-28 | `while (i < height) ...` | **データコピー**<br>既存の行のポインタを新しい配列にコピーします（文字列データ自体はコピーせず、ポインタのみ移動）。 |
| 29 | `new_map[height] = line;` | 新しい行を配列の最後に追加します。 |
| 30 | `new_map[height + 1] = NULL;` | 配列の終端を `NULL` でマークします。 |
| 31-32 | `if (map) free(map);` | **旧配列解放**<br>古いポインタ配列を解放します。中の文字列は新しい配列が参照しているため解放しません。 |

### 2. `cleanup_line`
#### プロトタイプ
`void cleanup_line(char *line)`

#### 戻り値
なし

#### 解説
文字列の末尾に含まれる改行文字（`\n` または `\r`）をヌル文字 `\0` に置換して削除します。これにより、マップデータの各行が純粋なマップ文字のみになります。

#### コード行別解説 (`cleanup_line`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 39-41 | `newline = ft_strchr(line, '\n'); ...` | **ラインフィード削除**<br>LF (`\n`) を検索し、見つかればヌル文字で上書きします。Unix環境での一般的な改行コードです。 |
| 42-44 | `newline = ft_strchr(line, '\r'); ...` | **キャリッジリターン削除**<br>CR (`\r`) も同様に削除します。Windows等で作成されたファイルに対応するためです。 |
