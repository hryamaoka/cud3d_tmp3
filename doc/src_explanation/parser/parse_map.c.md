# `src/parser/parse_map.c` 詳細解説

## 概要
設定要素のパースが終わった後の行から、ファイル末尾までをマップデータとして読み込みます。マップの幅と高さを計算し、各行の長さを最大幅に合わせてスペースで埋める（正規化）処理を行い、長方形のグリッドデータ `game->map.grid` を作成します。

## 依存関係
*   `parse.h`: パース用ヘッダ。
*   `libft.h`: `ft_strlen`, `ft_memcpy`, `ft_memset` 等。

## 関数詳細

### 1. `process_map_line`
#### プロトタイプ
`static int process_map_line(...)`

#### 戻り値
*   `1`: 正常処理。
*   `0`: エラー（マップ途中の空行など）。

#### 解説
読み込んだ1行をマップの一部として処理します。
*   空行の場合：マップ開始前なら無視、マップ途中なら「マップ終了フラグ」を立てます。
*   行末の改行削除、最大幅の更新を行い、`change_line_to_map`（`realloc`的な処理）で配列に追加します。

### 2. `normalize_map`
#### プロトタイプ
`static int normalize_map(t_game *game, char **temp_map, int height, int max_width)`

#### 戻り値
*   `1`: 成功。
*   `0`: メモリ確保失敗。

#### 解説
マップの各行の長さを揃えるために、短い行の後ろにスペースを埋めます。すべての行が `max_width` の長さを持つ長方形の配列（2次元配列）に変換します。これにより、後の処理でインデックス外参照を防ぎやすくなります。

### 3. `parse_map`
#### プロトタイプ
`int parse_map(int fd, t_game *game, char *first_line)`

#### 戻り値
*   `1`: マップパース成功。
*   `0`: 失敗。

#### 解説
`read_lines` で全行読み込んで一時配列を作成し、その後 `normalize_map` で整形して `t_game` にセットします。

### コード行別解説 (`parse_map`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 91 | `if (!read_lines(...))` | **行読み込み**<br>ファイルの残りを全て読み込みます。途中に空行が入る「分割マップ」などのエラーもここで検知されます。 |
| 94-98 | `if (height == 0)` | マップ行が1行もなかった場合（設定だけでファイルが終わっている場合）、エラーにします。 |
| 99 | `if (!normalize_map(...))` | **マップ正規化**<br>ガタガタの行長を揃えます。 |
| 104 | `return (1);` | 成功。 |
