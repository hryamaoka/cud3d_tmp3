# `src/parser/parse_main.c` 詳細解説

## 概要
マップファイルのパース処理全体を統括するファイルです。ファイルを開き、`get_next_line` で1行ずつ読み込みながら、テクスチャパス、色設定、そしてマップ配列を順次解析していきます。

## 依存関係
*   `parse.h`: パース関連の関数プロトタイプ。
*   `get_next_line.h`: 行読み込み関数。
*   `fcntl.h`: `open` 関数定数。

## 関数詳細

### 1. `process_elem_line`
#### プロトタイプ
`int process_elem_line(char *line, t_game *game, int *count)`

#### 戻り値
*   `1`: 正常に処理された（空行やコメント含む）、または要素が見つかった。
*   `0`: 不正な行（識別子がない等）が見つかった。この場合、マップの一部である可能性があるため、呼び出し元で判定に使われる。

#### 解説
ファイルの「設定部分」（マップ本体より前の部分）の1行を処理します。空行やコメント行はスキップし、テクスチャ(`NO`,`SO`...)や色(`F`,`C`)の設定行であれば解析関数を呼び出します。

#### コード行別解説 (`process_elem_line`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 16-19 | `if (is_empty_line(line)) ...` | **空行スキップ**<br>スペースやタブのみの行であれば、何もせずに `free` して `1`（成功）を返します。 |
| 20-28 | `while ... if (line[i] == '#' ...)` | **コメントスキップ**<br>行頭の空白を飛ばし、最初の文字が `#` または `//` であればコメント行とみなしてスキップします。 |
| 29-32 | `if (parse_texture...) else if (parse_color...)` | **要素解析**<br>行の内容がテクスチャパス指定または色指定であるかを判定し、成功すれば `count` をインクリメントします。 |
| 33-34 | `else return (0);` | **不明な行**<br>要素でも空行でもコメントでもない場合、`0` を返します。これは「設定記述が終わり、マップ記述が始まった」か「エラー」のどちらかです。 |

### 2. `parse_elem`
#### プロトタイプ
`char *parse_elem(int fd, t_game *game)`
*   `fd`: `open` 関数で取得した有効なファイルディスクリプタ（通常は 3 以上の正の整数）。`0`, `1`, `2` は標準入出力に予約されています。

#### 戻り値
*   `char *`: マップ部分の最初の行（設定要素が全て揃った後に現れた、マップデータと思われる最初の行）。
*   `NULL`: エラー時（ただし通常は `perror_and_exit` で終了するため到達しない）。

#### 解説
ループを回して設定要素（全6種類：東西南北テクスチャ＋床天井色）が揃うまで読み続けます。要素が揃う前に不明な行があればエラーとします。要素が6つ揃った時点で、その次の行（マップの開始行）を呼び出し元に返します。

#### コード行別解説 (`parse_elem`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 44-47 | `while (1) { line = get_next_line(fd); ... }` | **行読み込みループ**<br>ファイルの終わり（EOF）まで1行ずつ読み込みます。 |
| 48 | `if (!process_elem_line(line, game, &elem_count))` | 行を解析します。戻り値が `0` の場合（設定要素ではない行）、マップの開始行である可能性があります。 |
| 49-52 | `if (elem_count < 6) ...` | **不足エラー**<br>まだ6つの必須要素（テクスチャ4つ＋色2つ）が揃っていないのに不明な行（マップ行など）が現れた場合は、設定不足としてエラー終了します。 |
| 53 | `return (line);` | **マップ開始**<br>6つの要素が揃っており、かつ `process_elem_line` が `0` を返した場合、その行はマップデータの1行目とみなして返します。 |
| 56-57 | `if (elem_count < 6)` | ファイル末尾まで読んでも要素が揃わなかった場合のエラー処理です。 |

### 3. `parse`
#### プロトタイプ
`void parse(char *filename, t_game *game)`

#### 戻り値
なし

#### 解説
パース処理のエントリーポイントです。ファイルオープン、要素パース、マップパース、バリデーション（文字チェック、閉鎖チェック、プレイヤー検出）を順次実行します。

#### コード行別解説 (`parse`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 65 | `fd = open(filename, O_RDONLY);` | **ファイルオープン**<br>読み込み専用モードでファイルを開きます。 |
| 66-69 | `if (fd < 0) ...` | **オープンエラー判定**<br>`open` 関数は成功時にファイルディスクリプタ（正の整数）を返しますが、失敗時（ファイルが無い、権限がない等）には `-1` を返します。そのため、戻り値が `0` 未満かどうかでエラーを判定しています。 |
| 70 | `first_line = parse_elem(fd, game);` | **要素パース**<br>設定部分を読み込みます。戻り値 `first_line` にはマップデータの1行目が格納されます。 |
| 71-72 | `if (!parse_map(fd, game, first_line))` | **マップパース**<br>残りの行を読み込み、2次元配列 `game->map.grid` を作成します。失敗時はエラー終了。 |
| 73-74 | `if (!check_map_chars(game))` | **文字種チェック**<br>マップ内に許可されていない文字（0, 1, 2, N, S, E, W, 空白 以外）が含まれていないか確認します。 |
| 75-76 | `if (!check_map_closed(game))` | **壁の閉鎖チェック**<br>マップが壁(`1`)で囲まれているか、外に繋がっていないかを確認（Flood Fill等のアルゴリズムを使用）。 |
| 77-78 | `if (!find_player(game))` | **プレイヤー検出**<br>マップ内にプレイヤー（N/S/E/W）が「ただ1人」存在することを確認し、その位置と向きを記録します。 |
