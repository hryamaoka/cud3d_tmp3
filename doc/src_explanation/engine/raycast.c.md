# `src/engine/raycast.c` 詳細解説

## 概要
レイキャスティングの中核となる処理を行います。画面左端から右端まで1列ずつ光線（レイ）を飛ばし、壁との衝突判定、距離計算、テクスチャ座標の算出を経て、最終的な描画関数を呼び出します。3D空間の計算ロジックが詰まっています。

## 依存関係
*   `raycast.h`: レイキャスティング関連関数プロトタイプ。
*   `render.h`: 描画関数プロトタイプ。
*   `<math.h>`: `fabs`, `floor` 等。

## 関数詳細

### 1. `init_ray`
#### プロトタイプ
`void init_ray(t_game *game, int x)`

#### 戻り値
なし

#### 解説
画面上の列 `x` に対応する光線の方向ベクトルと初期値を設定します。

#### コード行別解説 (`init_ray`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 19 | `camera_x = 2 * x / (double)game->img.width - 1;` | **カメラスペース座標**<br>画面のX座標（0〜width）を、-1（左端）〜 1（右端）の正規化座標系に変換します。 |
| 20-21 | `game->ray.ray_dir_x = ...` | **レイの方向計算**<br>プレイヤーの向いている方向(`dir`)に、カメラ平面ベクトル(`plane`)を `camera_x` 倍したものを足して、この列のレイの方向ベクトルを求めます。 |
| 22-23 | `game->ray.map_x = ...` | レイの現在位置（グリッド座標）をプレイヤーの現在位置で初期化します。 |
| 24-25 | `game->ray.delta_dist_x = fabs(1 / ...);` | **デルタ距離**<br>レイがX（またはY）方向に1グリッド動くために必要なレイの長さを計算します。ピタゴラスの定理から導出されます。 |
| 27-28 | `init_ray_step_x(game);`... | レイの進行方向（正負）に応じて、ステップ（1 or -1）と最初の境界までの距離(`side_dist`)を計算する関数を呼び出します（`raycast_utils.c` で定義）。 |

### 2. `get_wall_x`
#### プロトタイプ
`static double get_wall_x(t_game *game)`

#### 戻り値
`double`: 壁のどこにヒットしたかを表す小数値（0.0〜1.0）。

#### 解説
壁に衝突した正確な位置を計算します。これはテクスチャのどの列を表示するか（テクスチャX座標）を決定するために必要です。

#### コード行別解説 (`get_wall_x`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 35 | `wall_x = game->player.y + ...` | **衝突位置の計算**<br>`side == 0`（縦壁ヒット）の場合、Y座標が「衝突点」になります。プレイヤーY位置に、「壁までの距離」×「レイのY成分」を足して求めます。 |
| 37 | `wall_x = game->player.x + ...` | `side == 1`（横壁ヒット）の場合、X座標が「衝突点」になります。 |
| 38 | `wall_x -= floor(wall_x);` | **小数部分の抽出**<br>グリッド座標（整数）を引いて、0.0〜1.0 の範囲（そのタイルのどこに当たったか）に正規化します。 |

### 3. `get_tex_x`
#### プロトタイプ
`static int get_tex_x(t_game *game, t_img *tex, double wall_x)`

#### 戻り値
`int`: テクスチャ上のX座標（0 〜 tex->width - 1）。

#### 解説
`wall_x` をテクスチャ幅に合わせて整数座標に変換し、壁の向きに応じて反転処理を行います。

#### コード行別解説 (`get_tex_x`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 45 | `tex_x = (int)(wall_x * (double)tex->width);` | 0.0〜1.0 の `wall_x` をテクスチャの幅（例: 64px）にスケールします。 |
| 46-48 | `if (...) tex_x = ... - 1;` | **テクスチャ反転**<br>南側の壁（`side=1, dir_y<0`）や西側の壁（`side=0, dir_x>0`）の場合、テクスチャが裏返しになってしまうため、X座標を反転させます(width - x - 1)。 |

### 4. `calc_wall_and_tex`
#### プロトタイプ
`static void calc_wall_and_tex(t_game *game, int *draw, t_img **tex, int *tex_x)`

#### 戻り値
なし（引数ポインタ `draw`, `tex`, `tex_x` に結果を格納）。

#### 解説
DDA完了後、壁の距離・高さ・テクスチャ座標など、描画に必要な最終情報を計算します。

#### コード行別解説 (`calc_wall_and_tex`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 54 | `if (game->ray.side == 0)` | **垂直距離の計算**<br>ヒットした面に応じて計算式を変えます。これはユークリッド距離ではなく、カメラ平面までの垂直距離を求めています（これにより壁が丸く歪むのを防ぎます）。 |
| 62 | `game->ray.line_height = ...` | 壁の高さを計算します。`距離 * 高さ = 定数` の反比例関係です。 |
| 63-68 | `draw[0] = ... draw[1] = ...` | **描画範囲決定**<br>壁の中心を画面中央に合わせます。上下がはみ出す場合のクランプ処理も含みます。 |
| 69 | `select_texture(game, tex);` | 壁の方角に応じたテクスチャ画像を選択します。 |
| 70 | `*tex_x = get_tex_x(...);` | テクスチャ上のX座標を計算します。 |

### 5. `raycast`
#### プロトタイプ
`void raycast(t_game *game)`

#### 戻り値
なし

#### 解説
画面の全列についてレイキャスティングを実行し、3Dビューを構築します。

#### コード行別解説 (`raycast`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 80 | `while (x < game->img.width)` | **列ごとのループ**<br>画面の左端から右端まで1列ずつ処理します。 |
| 81 | `init_ray(game, x);` | その列のレイを初期化します。 |
| 82 | `perform_dda(game);` | **DDA実行**<br>レイを飛ばして壁にぶつかるまで進めます。 |
| 83 | `calc_wall_and_tex(...);` | 衝突結果から描画情報を計算します。 |
| 84 | `game->z_buffer[x] = ...` | **Zバッファ保存**<br>スプライト描画の前後関係判定のために、この列の壁までの距離を記録します。 |
| 85-86 | `draw_floor_ceiling(...);`<br>`draw_textured_line(...);` | 天井・床を描画し、その上に壁を描画します。 |
