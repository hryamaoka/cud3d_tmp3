# `src/input/movement.c` 詳細解説

## 概要
プレイヤーの移動（前後左右）処理を行います。移動先の座標を計算し、壁との衝突判定（コリジョン）を行った上で、移動可能であればプレイヤー座標を更新します。

## 依存関係
*   `input.h`: `MOVE_SPEED`, `COLLISION_BUFFER` 定数。

## 関数詳細

### 1. `move_forward` / `move_backward`
プレイヤーの向いている方向ベクトル (`dir_x`, `dir_y`) に基づいて前後へ移動します。

### 2. `move_left` / `move_right`
方向ベクトルを90度回転させたベクトルを用いて、カニ歩き（平行移動）を行います。
*   右方向: `(-dir_y, dir_x)`
*   左方向: `(dir_y, -dir_x)`

### 共通ロジック（衝突判定）
各移動関数では、単純に座標を足すだけでなく、**「少し先の点（Collision Buffer）」** が壁に入り込まないかを確認します。
これにより、壁ギリギリまで近づいても埋まり込むことを防ぎます。
判定はX軸とY軸で独立して行われ、壁沿いに滑るような移動（Wall Sliding）が可能になっています。

### コード行別解説 (`move_forward`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 22-23 | `new_x = ...` | **移動先計算**<br>現在の座標に、速度(`MOVE_SPEED`)を掛けた方向ベクトルを加算します。 |
| 24-31 | `if (game->player.dir_x > 0) ...` | **バッファ位置決定**<br>進行方向に応じて、衝突判定を行うポイントを少し前方(`COLLISION_BUFFER`)にずらします。 |
| 32-34 | `if (new_x >= 0 ... != '1' ... != 'D')` | **X軸移動判定**<br>移動先の「X座標」と「現在のY座標」のマスが壁でないか確認します。安全ならX座標のみ更新します。 |
| 36-39 | `if (new_y >= 0 ...)` | **Y軸移動判定**<br>同様に「現在のX座標」と「移動先のY座標」のマスを確認し、安全ならY座標を更新します。 |

### コード行別解説 (`move_backward`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 48-49 | `new_x = ... - ...` | **移動先計算**<br>進行方向と逆（マイナス）に進みます。 |
| 50-57 | `if (-game->player.dir_x > 0) ...` | バッファ位置も逆方向をもとに計算します。衝突判定ロジックは `move_forward` と同じです。 |

### コード行別解説 (`move_left`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 76-77 | `dx = game->player.dir_y; dy = -game->player.dir_x;` | **左ベクトル計算**<br>方向ベクトル `(x, y)` を左に90度回転させると `(y, -x)` になります。 |
| 78-79 | `new_x = ...` | 左方向ベクトルを使って移動先を算出します。 |

### コード行別解説 (`move_right`)

| 行番号 | コード | 詳細解説 |
| :--- | :--- | :--- |
| 106-107 | `dx = -game->player.dir_y; dy = game->player.dir_x;` | **右ベクトル計算**<br>方向ベクトル `(x, y)` を右に90度回転させると `(-y, x)` になります。 |
