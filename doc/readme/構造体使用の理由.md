# t_game 構造体を使用している理由

本プロジェクトでは、ゲームの全データを管理するために `t_game` という巨大な構造体を1つ定義し、使用しています。その主な理由は以下の通りです。

## 1. グローバル変数の回避とNorminette準拠
42のコーディング規約 (Norminette) では、**グローバル変数の使用が禁止**されています。
ゲームの状態（プレイヤー位置、マップデータ、MLXポインタなど）をプログラム全体で共有する必要がありますが、グローバル変数が使えないため、これら全てのデータを1つの構造体 (`t_game`) にまとめ、そのポインタを各関数に渡して回る設計が推奨されます。

## 2. 関数の引数を減らす (引数制限の回避)
Norminetteには「1つの関数につき引数は4つまで」という制限があります。
もし構造体を使わずに個別の変数を渡そうとした場合、レンダリング関数などは `mlx`, `win`, `px`, `py`, `dir_x`, `dir_y`, `map`... と膨大な数の引数が必要になり、4つの制限を大幅に超えてしまいます。
`t_game *game` という1つのポインタを渡すだけで、関数内で必要な全てのデータにアクセスできるようになり、引数制限をクリアしつつコードを綺麗に保てます。

## 3. メモリ管理の一元化
ゲーム終了時やエラー発生時に、確保したメモリ（マップ解析結果、テクスチャ画像、MLXインスタンスなど）を全て解放（free）する必要があります。
データが `t_game` に集約されていることで、`free_all(t_game *game)` のような関数を1つ用意すれば、再帰的に全てのメンバを解放していく処理が書きやすくなり、メモリリークのリスクを減らせます。

## 4. 拡張性の確保
後から「ボーナス機能でスプライトを追加したい」「ミニマップの色情報を増やしたい」となった場合でも、関数の引数を書き換える必要がありません。
構造体 `t_game` に新しいメンバ変数を追加するだけで、既存の関数シグネチャ（引数定義）を変更することなく、プログラム内のどこからでも新しいデータにアクセスできるようになります。

---

### 参考: t_game の主な構成要素 (`includes/cub3d.h`)

| メンバ | 用途 |
| :--- | :--- |
| `void *mlx`, `*win` | MiniLibXのインスタンスとウィンドウ管理 |
| `t_img img` | 描画用のメイン画像バッファ（ダブルバッファリング用） |
| `t_map map` | パースしたマップデータ（グリッド、幅、高さ） |
| `t_player player` | プレイヤーの座標、向きベクトル、カメラ平面 |
| `t_ray ray` | レイキャスティング計算時に使う一時変数群 |
| `t_tex tex` | テクスチャのファイルパス情報 |
| `t_img wall_tex[4]` | 読み込んだ壁テクスチャ画像データ |
