# Cub3D プログラム詳細仕様書

## 1. プロジェクト概要

### 1.1 目的
**Cub3D** は、C言語とグラフィックライブラリ **MiniLibX** を用いて実装された「レイキャスティング (Raycasting)」エンジンのデモプログラムです。
1992年のFPSゲーム『Wolfenstein 3D』の技術を再現し、2Dのマップデータから疑似的な3D迷路空間をリアルタイムにレンダリングすることを目的としています。

### 1.2 主な機能
*   **.cub ファイルのパース**: マップ形状、テクスチャパス、天井・床の色設定を含むシーン記述ファイルを読み込みます。
*   **3Dレンダリング**: DDAアルゴリズムを用いたレイキャスティングにより、壁の距離計算と描画を行います。
*   **テクスチャマッピング**: 壁の向き（東西南北）に応じた異なるテクスチャの貼り付け。
*   **プレイヤー操作**: 視点移動、前後左右への移動。
*   **衝突判定**: 壁へのめり込み防止（Wall Collision）。
*   **ボーナス機能**:
    *   ドアの開閉（インタラクション）
    *   スプライト（アイテム等）の描画とビルボード処理
    *   ミニマップ表示
    *   マウスによる視点操作

---

## 2. 動作環境・ビルド方法

### 2.1 推奨環境
*   **OS**: Linux (Ubuntu 20.04 LTS 等) または WSL2 (Windows Subsystem for Linux)
*   **コンパイラ**: gcc, clang
*   **ライブラリ**: MiniLibX (Linux版), libX11, libXext, math library (`-lm`)

### 2.2 ビルドコマンド
プロジェクトルートで `make` を実行することで、実行ファイル `cub3D` が生成されます。

```bash
make        # 標準ビルド
make clean  # オブジェクトファイルの削除
make fclean # 実行ファイルを含む全生成物の削除
make re     # 再ビルド
```

### 2.3 実行方法
第一引数に `.cub` 形式のマップファイルを指定して実行します。

```bash
./cub3D maps/valid/simple.cub
```

---

## 3. 入力データ仕様 (.cub形式)

設定ファイルは以下のルールに従う必要があります。

### 3.1 テクスチャ指定
壁の各方向（North, South, West, East）に対応するテクスチャファイル（`.xpm`）のパスを指定します。

```text
NO ./path/to/north.xpm
SO ./path/to/south.xpm
WE ./path/to/west.xpm
EA ./path/to/east.xpm
```

### 3.2 色指定
床 (`F`) と天井 (`C`) の色を R,G,B (0-255) で指定します。

```text
F 220,100,0
C 225,30,0
```

### 3.3 マップデータ
ファイルの末尾に記述します。
*   `0`: 床（移動可能）
*   `1`: 壁
*   `2`: スプライト（アイテム等）
*   `N`, `S`, `E`, `W`: プレイヤーの初期位置（文字が向いている方角を意味する）
*   `D`: 閉じたドア（ボーナス）
*   `O`: 開いたドア（内部処理用だがマップに記述も可）
*   ` ` (スペース): マップ外（壁で囲まれていること）

**制約事項**:
*   マップは必ず「壁 (`1`)」で周囲を完全に囲まれている必要があります（Flood Fillアルゴリズム等で検証）。
*   プレイヤーはマップ内にただ1人だけ存在する必要があります。

---

## 4. ユーザーインターフェース・操作方法

### 4.1 キーボード操作
WSL環境/Linux標準のキーコード（X11）に基づきます。

| キー | 動作 | コード例 (src/input/keys.h) |
| :--- | :--- | :--- |
| **W** | 前進 | `KEY_W` (119) |
| **S** | 後退 | `KEY_S` (115) |
| **A** | 左平行移動（カニ歩き） | `KEY_A` (97) |
| **D** | 右平行移動 | `KEY_D` (100) |
| **←** | 左回転 | `KEY_LEFT` (65361) |
| **→** | 右回転 | `KEY_RIGHT` (65363) |
| **E** | ドアの開閉 | `KEY_E` (101) |
| **ESC** | ゲーム終了 | `KEY_ESC` (65307) |

### 4.2 マップ操作
*   **ウィンドウの×ボタン**: ゲームを終了し、リソースを解放します。
*   **マウス操作**: マウスを左右に動かすことで視点を回転させることができます（ボーナス機能）。

---

## 5. システムアーキテクチャ詳細

プログラムは大きく分けて「初期化・パース」「メインループ（更新・描画）」「終了処理」の3フェーズで構成されています。

### 5.1 データ構造 (`include/cub3d.h`)

#### `t_game` (メイン構造体)
全てのゲーム情報を保持するGod Objectです。
*   `mlx`, `win`: MiniLibXのポインタ
*   `img`: 描画用のイメージバッファ操作体
*   `map`: マップデータ（2次元配列、幅、高さ）
*   `player`: プレイヤーの位置、方向ベクトル
*   `ray`: レイキャスティング計算用の一時変数群
*   `tex`: テクスチャ情報
*   `sprites`: スプライトの配列

#### `t_ray` (レイ情報)
光線一本ごとの計算状態を保持します。
*   `ray_dir_x`, `ray_dir_y`: 光線の方向ベクトル
*   `map_x`, `map_y`: 現在チェックしているグリッド座標
*   `side_dist_x`, `side_dist_y`: 次の境界線までの距離
*   `delta_dist_x`, `delta_dist_y`: グリッド1マス分の距離
*   `perp_wall_dist`: カメラ平面からの垂直距離（魚眼補正後）
*   `side`: 壁の向き（0:東西, 1:南北）

### 5.2 アルゴリズム詳細

#### (1) DDA (Digital Differential Analyzer)
レイキャスティングの核心部分です。
1.  **初期化**: レイの方向から `step_x/y`（進行方向）と `side_dist`（最初の境界までの距離）を計算。
2.  **ループ**: `side_dist` が小さい方の軸（XまたはY）を、グリッド1つ分進める。これを壁(`1`)かドア(`D`)に当たるまで繰り返す。
3.  **距離計算**: ループを抜けた時点での累積距離から、カメラ平面への垂直距離 `perp_wall_dist` を求める。これにより、単純なユークリッド距離を使うと発生する「魚眼効果（壁が丸く歪む現象）」を防ぐ。

#### (2) テクスチャマッピング
壁の描画時に、どのテクスチャのどの部分を表示するかを決定します。
1.  **壁の特定**: `ray.side` と `ray_dir` の正負から、東西南北、ドア等のテクスチャを選択。
2.  **X座標計算 (`tex_x`)**: 壁の衝突地点の正確な座標（小数）から、テクスチャ上のX座標を算出。
3.  **Y座標計算 (`tex_y`)**: 描画する縦ラインの各ピクセルについて、壁の高さに応じたスケーリングを行い、テクスチャ上のY座標をサンプリングする。

#### (3) スプライト描画 (Billboarding)
1.  **投影変換**: スプライトのワールド座標を、プレイヤのカメラ行列の逆行列を用いて「カメラスペース」に変換。
2.  **ソート**: Zバッファ法が使えない（透明部分がある）ため、**遠いスプライトから順に**描画する（Painter's Algorithm）。
3.  **1D Zバッファ**: 壁が既に描画されている場所にはスプライトを描画しないよう、レイキャスティング時に作成した `z_buffer`（各列の壁までの距離）と比較する。

#### (4) 衝突判定 (Collision Detection)
プレイヤーの新しい座標候補 `(new_x, new_y)` を計算した後、その位置が壁の中に入り込んでいないかをチェックします。
*   単に中心点を見るだけでなく、プレイヤーの体幅分（`COLLISION_BUFFER`）を考慮した余白を含めて判定します。
*   X軸移動とY軸移動を独立して判定・適用することで、壁に向かって斜めに進んだ際に「壁沿いに滑る (Wall Sliding)」挙動を実現しています。

---

## 6. ファイル構成

### ルートディレクトリ
*   `Makefile`: ビルドスクリプト
*   `cub3D`: 生成される実行ファイル

### `src/` (ソースコード)
ディレクトリ単位で機能がモジュール化されています。

#### `src/main.c`
エントリーポイント。引数チェック、メインループの開始を担当。

#### `src/parser/` (構文解析)
*   **`parse_main.c`**: パース処理の統括。
*   **`parse_map.c`**: マップデータの読み込みと正規化（長方形化）。
*   **`parse_textures.c`**: テクスチャパスの解析。
*   **`parse_colors.c`**: RGB色の解析とバリデーション。
*   **`check_file.c`**: ファイル拡張子チェック。
*   **`valid_map.c`**: マップの閉鎖性チェック（重要）。

#### `src/core/` (コア機能)
*   **`game_init.c`**: 構造体の初期化 (`init_game`)。
*   **`window.c`**: MLXウィンドウの生成 (`init_window`)。
*   **`error.c`**: エラーメッセージ出力と強制終了処理 (`perror_and_exit`)。
*   **`game_cleanup.c`**: メモリ解放 (`free_all`)。

#### `src/engine/` (3D演算エンジン)
*   **`raycast.c`**: レイキャスティングのメインループ。
*   **`raycast_utils.c`**: DDAアルゴリズム、テクスチャ選択ロジック。

#### `src/render/` (描画処理)
*   **`render.c`**: フレームごとの描画パイプライン。
*   **`minimap.c`**: 2Dミニマップの描画。
*   **`sprite.c`, `sprite_utils.c`**: スプライトのソートと描画。

#### `src/input/` (入力処理)
*   **`keys.h`**: キーコード定義。
*   **`input.h`**: 移動速度などのパラメータ定数。
*   **`action.c`**: キー入力の分配、ドア操作。
*   **`movement.c`**: 移動ロジックと衝突判定。
*   **`rotate.c`**: 視点回転ロジック。

#### `src/utils/` (ユーティリティ)
*   **`utils.c`**: `ft_abs` 等のヘルパー関数。

---

## 7. メモリ管理とエラー処理

### 7.1 メモリ管理
*   **一元管理**: `t_game` 構造体に全ての動的確保リソース（ポインタ）を集約しています。
*   **終了処理**: プログラム終了時（正常・異常問わず）には必ず `free_all()` が呼ばれ、以下の順序で解放を行います。
    1.  マップ配列 (`grid`) の解放
    2.  テクスチャ構造体内のイメージポインタの破棄 (`mlx_destroy_image`)
    3.  Zバッファ、スプライト配列の解放
    4.  ウィンドウ、ディスプレイの破棄 (`mlx_destroy_window`, `mlx_destroy_display`)
    5.  MLX本体の解放

### 7.2 エラーハンドリング
*   パース失敗、ファイル読み込み失敗、メモリ確保失敗などの致命的なエラーが発生した場合、即座に標準エラー出力に詳細なメッセージを表示し、全てのリソースを解放して終了します（`exit(1)`）。セグメンテーションフォールトによる不正終了を防ぐ設計になっています。
